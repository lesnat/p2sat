#coding:utf8
import numpy as np

from ._Raw import _Raw
from ._Hist import _Hist
from ._Plot import _Plot
from ._Tools import _Tools

class PhaseSpaceGeneric(object):
  """
  Base class for particle phase-space analysis.
  
  Attributes
  ----------
  extract : "polymorphic" method
    load phase space from a simulation file
  raw : sub-object
    contains raw data and methods to manipulate it, such as import/export into a file or value filtering method. Appropriate place to IO ?
  hist : sub-object
    contains methods to make histograms from raw data
  plot : sub-object
    contains methods to plot histos
  
  Notes
  -----
  See sub-objects documentation for more informations
  """
  def __init__(self):
      self.raw  = _Raw()
      self.hist = _Hist(self)
      self.plot = _Plot(self)
      self.tools= _Tools(self)
  
  def extract(self):
    """
    Extract raw data from a simulation file.
    
    Notes
    -----
    This abstract method must be overwritten by the _PhaseSpace child classes
    """
    raise NotImplementedError
      

class PhaseSpaceSmilei(PhaseSpaceGeneric):
  def __init__(self):
      self.raw  = _Raw()
      self.hist = _Hist(self)
      self.plot = _Plot(self)
      self.tools= _Tools(self)
  
  def extract_1d(self,Screen,timestep,xnorm,wnorm=1.0,X=0):
    w         = []
    x,y,z     = [],[],[]
    px,py,pz  = [],[],[]
    
    data= Screen(timesteps=timestep).getData()[0]
    Px  = Screen().get()['px'] * 0.511
    Py  = Screen().get()['py'] * 0.511
    
    try:
      Y = Screen().get()['y'] * xnorm
    except:
      Y = [0.0]
      data = [data]
    
    wNorm = wnorm/(0.511**2)
    wNorm *= (max(Px)-min(Px))/len(Px)
    wNorm *= (max(Py)-min(Py))/len(Py)
    
    # redéfinir l'ordre dans namelist ?
    print("Extracting screen data ...")
    for iy,ey in enumerate(data):
      for ipx,epx in enumerate(ey):
        for ipy,epy in enumerate(epx):
          if epy!=0:
            y.append(Y[iy])
            px.append(Px[ipx])
            py.append(Py[ipy])
            w.append(epy*wNorm)

    pz = [0.0] * len(w)
    x = [X] * len(w)
    z = [0.0] * len(w)
    print("Data succesfully imported")
    self.raw.update(w,x,y,z,px,py,pz)
    
  def extract_2d(self,Screen,timestep,xnorm,wnorm=1.0,X=0):
    w         = []
    x,y,z     = [],[],[]
    px,py,pz  = [],[],[]
    
    data= Screen(timesteps=timestep).getData()[0]
    Px  = Screen().get()['px'] * 0.511
    Py  = Screen().get()['py'] * 0.511
    Pz  = Screen().get()['pz'] * 0.511


    
    try:
      Y = Screen().get()['y'] * xnorm
    except:
      Y = [0.0]
      data = [data]
    
    wNorm  = wnorm/(0.511**3)
    wNorm *= (max(Px)-min(Px))/len(Px)
    wNorm *= (max(Py)-min(Py))/len(Py)
    wNorm *= (max(Pz)-min(Pz))/len(Pz)
    # redéfinir l'ordre dans namelist ?
    print("Extracting screen data ...")
    for iy,ey in enumerate(data):
      for ipx,epx in enumerate(ey):
        for ipy,epy in enumerate(epx):
          for ipz,epz in enumerate(epy):
            if epz!=0:
              y.append(Y[iy])
              px.append(Px[ipx])
              py.append(Py[ipy])
              pz.append(Pz[ipz])
              w.append(epz*wNorm)
              
    x = [X] * len(w)
    z = [0.0] * len(w)
    print("Data succesfully imported")
    self.raw.update(w,x,y,z,px,py,pz)


class PhaseSpaceGeant4(PhaseSpaceGeneric):
  def __init__(self):
    self.raw  = _Raw()
    self.hist = _Hist(self)
    self.plot = _Plot(self)
    self.tools= _Tools(self)

    
  def extract(self,file_name,nthreads=1):
    data = []
    fext = file_name[-4:]
    
    if fext=="root":
      pass
    else:
      for thread in range(0,nthreads):
        fname=file_name[:-5]+"%s"%thread+fext
        print("Extracting %s ..."%fname)

        if fext==".csv":
          with open(fname,'r') as f:
            for line in f.readlines():
              if line[0]!='#':
                for e in line.split(','):
                  data.append(float(e))
        
        if fext==".xml":
          from lxml import etree      
          tree = etree.parse(fname)
          for entry in tree.xpath('/aida/tuple/rows/row/entry'):
            data.append(float(entry.get('value')))
    
    w   = data[0::7]
    x   = data[1::7]
    y   = data[2::7]
    z   = data[3::7]
    px  = data[4::7]
    py  = data[5::7]
    pz  = data[6::7]
    print("Data succesfully imported")
    
    self.raw.update(w,x,y,z,px,py,pz)
      
